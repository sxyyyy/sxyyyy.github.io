<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于转专业</title>
    <link href="/2024/07/28/%E5%85%B3%E4%BA%8E%E8%BD%AC%E4%B8%93%E4%B8%9A/"/>
    <url>/2024/07/28/%E5%85%B3%E4%BA%8E%E8%BD%AC%E4%B8%93%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="关于转专业"><a href="#关于转专业" class="headerlink" title="关于转专业"></a>关于转专业</h1><p>昨天晚上出的结果, 我几乎一直盯着学院官网, 隔上两分钟我就刷新几次, 大概是七点多还是八点多出的结果, 我记不得了. 结果一出, 我立刻从手机上把表格下了下来, 然后打开. </p><p>没有我. </p><p>我又确认了一遍, 确实没有我. </p><p>这种感觉很熟悉, 初三的时候考推荐生, 我也没考上. 不过我这次没有那么悲痛了, 明明这次的影响会比那次更大, 但是我心中的波澜却是更小的. 是因为更成熟了吗? 是因为经历的更多了吗? 还是因为我提前做好心理准备了? </p><p>我不知道. </p><p>昨天晚上我本来想喝点啤酒的, 结果出来之后, 我把杯子里的啤酒换成了白酒. 当时我已经吃饱饭了, 所以几乎是干喝. 旁边有父母他们, 还有两个发小, 他们在一旁畅谈, 我自己在调整心态, 说一点也不失落是不可能的. 大家举起酒杯, 碰杯, 喝酒, 过了一会, 我直接干杯了. 大概是因为喝的有些快, 而且是干喝, 我没多久就有些晕了, 但是我没醉, 我的大脑很清醒, 对世界的感受很清晰. </p><p>“那时我们有梦, 关于文学, 关于爱情, 关于穿越世界的旅行. 如今我们深夜饮酒, 杯子碰到一起, 都是梦破碎的声音. “ </p><p>喝到了大概十一点, 我们出门了, 去唱歌. 从十二点唱到了三点, 到家时已是凌晨三点半. </p><p>不知道是不是酒精的原因, 感觉昨天晚上很高兴, 过的很快, 好像什么都没发生一样. 在结果出来之前, 身边的人几乎都觉得我稳了, 老师相信我, 学长学姐相信我, 同学相信我, 连未曾谋面的网友也相信我, 包括我自己都是很自信的. 但是结果就是这样. 如果只是我自己的话, 其实好像没什么, 就是觉得自己好像辜负了其他人, 心里有些过意不去. 出来结果之后, 也是有很多人来安慰我, 学长学姐, 同学, 还有学弟, 认识的, 未曾谋面的. 这是我记忆里第一次有这么多人安慰我, 或者说, 认可我. </p><p>在出结果之前我连转成功之后想说些什么都想好了哈哈哈. </p><p>这次转专业失败, 也算是让我放下了些什么, 放下了一些外在的, 不是我自己内心的东西. 其实我早就在脑子里面想过了, 转专业失败, 非科班出身, 草根黑客, 也未尝不是一段佳话啊哈哈哈. </p><p>虽然结果是失败了, 但是这个过程我还蛮开心的, 这次转专业让我重新审视了我曾经与网安的邂逅, 从相遇相识, 到相知, 到我爱上这个行业, 并决定把她作为我一生的事业. 让我想起了高中时在自习课上偷偷看书的日子, 想起了高中时中午不吃饭, 回宿舍一边看书一边啃面包的日子, 现在想来, 那真是一段为了热爱不顾一切的时光. </p><p>转之前我还会觉得自己在这方面的经历丰富, 比身边大多数人的认知要高一些. 但是现在看来, 我其实没有什么不同, 我不过是一个热爱网安的人, 一个热爱计算机的人, 一个普通人. </p><p>我喜欢安慰别人, 现在我把我对别人说过的话又重新对自己说了一遍, 我每次安慰别人, 又何尝不是在安慰另一个自己, 在遇到相同或是类似的境遇时, 那一个我就出现了. </p>]]></content>
    
    
    <categories>
      
      <category>Story</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Something</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大堰河——我的保姆</title>
    <link href="/2024/07/15/%E5%A4%A7%E5%A0%B0%E6%B2%B3%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/"/>
    <url>/2024/07/15/%E5%A4%A7%E5%A0%B0%E6%B2%B3%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/</url>
    
    <content type="html"><![CDATA[<h1 id="大堰河——我的保姆"><a href="#大堰河——我的保姆" class="headerlink" title="大堰河——我的保姆"></a>大堰河——我的保姆</h1><h2 id="记"><a href="#记" class="headerlink" title="记"></a>记</h2><p>今天晚上去父亲那边吃饭, 虽然父亲并不在.</p><p>在吃完饭的空余, 我便自发地走向了书架, 扫视了一眼书架上的书. 在这我已浏览过无数遍的目录上, 我意外地发现了一本在此等候已久的书.</p><p>艾青诗选是初中时买的, 因为这是初中的必读书, 所谓必读, 对于当时的我来说就是”要考”. 既然是要考, 那自然就是只看考的内容, 对其他内容则是能不看就不看. 这就是应试教育带给我的”收获”, “节约”了我大把的时间.</p><p>既然已经不需要考了, 那我现在就可以沉下心来好好读一读了.</p><p>第一首诗便是这首, 大堰河——我的保姆.</p><p>我流泪了.</p><p>这首诗的情感有些太充沛了, 以至于我在朗读的时候深深的共情了.</p><blockquote><p>大堰河，今天我看到雪使我想起了你：<br>你的被雪压着的草盖的坟墓，<br>你的关闭了的故居檐头的枯死的瓦菲，<br>你的被典押了的一丈平方的园地，<br>你的门前的长了青苔的石椅，<br>大堰河，今天我看到雪使我想起了你。</p></blockquote><p>关闭的故居, 典押的园地, 长了青苔的石椅, 这些地方想必都发生了难忘的故事吧, 那些故事是不是也像故居一样关闭了, 像园地一样典押了, 像石椅一样长满青苔了呢, 诗人的记忆是否也像这样尘封起来了呢? 似乎并没有, 诗人一直记得, 一直记得大堰河, 一直记得他们之间那些难忘的故事. 世界一直在变化, 被雪掩埋, 可诗人的记忆却始终没变. 那一切, 都被这场雪打开了.</p><blockquote><p>我是地主的儿子，<br>在我吃光了你大堰河的奶之后，<br>我被生我的父母领回到自己的家里。<br>啊，大堰河，你为什么要哭？</p></blockquote><p>“啊, 大堰河, 你为什么要哭?”, 哭的只是大堰河吗, 诗人是否也哭了, 我不知道, 但是我哭了.</p><p>大堰河已经死了, 诗人在狱中为她写下了这首赞诗.</p><p>这首饱含深情的诗, 没有很华丽的辞藻, 没有刻意的韵律, 没有很”精致”, 但是充满感情. 它讲好了一个故事, 一首生的悲歌, 死的赞歌.</p><p>这是我所缺失的, 也是我一直所在寻找的, 如何讲好一个故事.</p><h2 id="诗"><a href="#诗" class="headerlink" title="诗"></a>诗</h2><p><strong>大堰河——我的保姆</strong><br>艾青</p><p>大堰河，是我的保姆。<br>她的名字就是生她的村庄的名字，<br>她是童养媳，<br>大堰河，是我的保姆</p><p>我是地主的儿子；<br>也是吃了大堰河的奶而长大了的<br>大堰河的儿子。<br>大堰河以养育我而养育她的家，<br>而我，是吃了你的奶而被养育了的，<br>大堰河啊，我的保姆。</p><p>大堰河，今天我看到雪使我想起了你：<br>你的被雪压着的草盖的坟墓，<br>你的关闭了的故居檐头的枯死的瓦菲，<br>你的被典押了的一丈平方的园地，<br>你的门前的长了青苔的石椅，<br>大堰河，今天我看到雪使我想起了你。</p><p>你用你厚大的手掌把我抱在怀里，抚摸我；<br>在你搭好了灶火之后，<br>在你拍去了围裙上的炭灰之后，<br>在你尝到饭已煮熟了之后，<br>在你把乌黑的酱碗放到乌黑的桌子上之后，<br>在你补好了儿子们的为山腰的荆棘扯破的衣服之后，<br>在你把小儿被柴刀砍伤了的手包好之后，<br>在你把夫儿们的衬衣上的虱子一颗颗地掐死之后，<br>在你拿起了今天的第一颗鸡蛋之后，<br>你用你厚大的手掌把我抱在怀里，抚摸我。</p><p>我是地主的儿子，<br>在我吃光了你大堰河的奶之后，<br>我被生我的父母领回到自己的家里。<br>啊，大堰河，你为什么要哭？</p><p>我做了生我的父母家里的新客了！<br>我摸着红漆雕花的家具，<br>我摸着父母的睡床上金色的花纹，<br>我呆呆地看着檐头的我不认得的“天伦叙乐”的匾，<br>我摸着新换上的衣服的丝的和贝壳的纽扣，<br>我看着母亲怀里的不熟识的妹妹，<br>我坐着油漆过的安了火钵的炕凳，<br>我吃着碾了三番的白米的饭，<br>但，我是这般忸怩不安！因为我<br>我做了生我的父母家里的新客了。</p><p>大堰河，为了生活，<br>在她流尽了她的乳汁之后，<br>她就开始用抱过我的两臂劳动了；<br>她含着笑，洗着我们的衣服，<br>她含着笑，提着菜篮到村边的结冰的池塘去，<br>她含着笑，切着冰屑悉索的萝卜，<br>她含着笑，用手掏着猪吃的麦糟，<br>她含着笑，扇着炖肉的炉子的火，<br>她含着笑，背了团箕到广场上去,<br>晒好那些大豆和小麦，<br>大堰河，为了生活，<br>在她流尽了她的乳液之后，<br>她就用抱过我的两臂，劳动了。</p><p>大堰河，深爱着她的乳儿；<br>在年节里，为了他，忙着切那冬米的糖，<br>为了他，常悄悄地走到村边的她的家里去，<br>为了他，走到她的身边叫一声“妈”，<br>大堰河，把他画的大红大绿的关云长<br>贴在灶边的墙上，<br>大堰河，会对她的邻居夸口赞美她的乳儿；<br>大堰河曾做了一个不能对人说的梦：<br>在梦里，她吃着她的乳儿的婚酒，<br>坐在辉煌的结彩的堂上，<br>而她的娇美的媳妇亲切的叫她“婆婆”<br>……<br>大堰河，深爱着她的乳儿！</p><p>大堰河，在她的梦没有做醒的时候已死了。<br>她死时，乳儿不在她的旁侧，<br>她死时，平时打骂她的丈夫也为她流泪，<br>五个儿子，个个哭得很悲，<br>她死时，轻轻地呼着她的乳儿的名字，<br>大堰河，已死了，<br>她死时，乳儿不在她的旁侧。</p><p>大堰河，含泪的去了！<br>同着四十几年的人世生活的凌侮，<br>同着数不尽的奴隶的凄苦，<br>同着四块钱的棺材和几束稻草，<br>同着几尺长方的埋棺材的土地，<br>同着一手把的纸钱的灰，<br>大堰河，她含泪的去了。</p><p>这是大堰河所不知道的：<br>她的醉酒的丈夫已死去，<br>大儿做了土匪，<br>第二个死在炮火的烟里，<br>第三，第四，第五<br>在师傅和地主的叱骂声里过着日子。<br>而我，我是在写着给予这不公道的世界的咒语。<br>当我经了长长的漂泊回到故土时，<br>在山腰里，田野上，<br>兄弟们碰见时，是比六七年前更要亲密！<br>这，这是为你，静静地睡着的大堰河<br>所不知道的啊！</p><p>大堰河，今天，你的乳儿是在狱里，<br>写着一首呈给你的赞美诗，<br>呈给你黄土下紫色的灵魂，<br>呈给你拥抱过我的直伸着的手，<br>呈给你吻过我的唇，<br>呈给你泥黑的温柔的脸颜，<br>呈给你养育了我的乳房，<br>呈给你的儿子们，我的兄弟们，<br>呈给大地上一切的，<br>我的大堰河般的保姆和她们的儿子，<br>呈给爱我如爱她自己的儿子般的大堰河。</p><p>大堰河，<br>我是吃了你的奶而长大了的<br>你的儿子，<br>我敬你<br>爱你！</p><p>一九三三年一月十四日，雪朝</p>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>现代诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Learning Chapter 2</title>
    <link href="/2024/07/10/Python-Learning-Chapter-2/"/>
    <url>/2024/07/10/Python-Learning-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Learning-Chapter-2"><a href="#Python-Learning-Chapter-2" class="headerlink" title="Python Learning Chapter 2"></a>Python Learning Chapter 2</h1><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><p>一个<strong>函数</strong>的<strong>定义</strong>通常如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> &lt;name&gt;(&lt;formal parameters&gt;):<br>  ...<br>  <span class="hljs-keyword">return</span> ...<br></code></pre></td></tr></table></figure><p>开头为一个 <code>def</code> 语句, 然后是函数的名, 后面跟着 <code>()</code>, <code>()</code> 里是若干个用 <code>,</code> 隔开的形参. 下面是函数要进行的操作, 最后是一个 <code>return</code> 语句(可有可无)用于返回值.</p><p>函数的定义很简单, 接下来我们看一点抽象的东西.</p><p>我们知道, 给一个变量赋值用的是 <code>=</code>, 定义一个函数用的是 <code>def</code>, 无论是 <code>=</code> 还是 <code>def</code>, 其本质都是为一个<strong>名</strong>赋予<strong>含义</strong>, 换句话说, <code>def</code> 语句本质上也是一个<strong>赋值语句</strong>.</p><p>所以很多时候, 我们把函数的定义当作是对名的赋值就会好理解很多.</p><h3 id="Functions-as-Arguments"><a href="#Functions-as-Arguments" class="headerlink" title="Functions as Arguments"></a>Functions as Arguments</h3><p>观察以下几个函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + k, k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_cubes</span>(<span class="hljs-params">n</span>):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + k * k * k, k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pi_sum</span>(<span class="hljs-params">n</span>):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + <span class="hljs-number">8</span> / ((<span class="hljs-number">4</span> * k - <span class="hljs-number">3</span>) * (<span class="hljs-number">4</span> * k - <span class="hljs-number">1</span>)), k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>我们可以发现以上几个函数都可以写成如下格式:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> &lt;name&gt;(n):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + &lt;term&gt;(k), k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>只有函数名 <code>&lt;name&gt;</code> 和参数的计算方式 <code>&lt;term&gt;</code> 不同.</p><p>我们在上一章提到过, python 中不分函数名或是变量名, 而是统一称为<strong>名(name)</strong>, 既然这样, 我们在函数中传参的过程中, 也可以通过名的形式来传入一个函数, 即上面的 <code>&lt;term&gt;</code>.</p><p>也就是说, 我们可以把函数作为一个参数传入函数.</p><p>故函数 <code>sum_cubes</code> 的定义可以改写为如下形式:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">summation</span>(<span class="hljs-params">n, term</span>):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + term(k), k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> x * x * x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_cubes</span>(<span class="hljs-params">n</span>):<br>  <span class="hljs-keyword">return</span> summation(n, cube)<br></code></pre></td></tr></table></figure><p>只考虑计算立方和这一项功能的话, 把一个函数拆成这样三个函数来写可能有些不合适, 但是当我们把所有的可以用该格式概括的(前 n 项求和)函数都写成这样的形式, 那我们的代码复用性就大大的提高了, 这种模块化的思想是编程的哲学, 也是编程的艺术, 既提高了代码的复用性, 也提高了代码的美观程度.</p><h3 id="Nested-Definitions"><a href="#Nested-Definitions" class="headerlink" title="Nested Definitions"></a>Nested Definitions</h3><p>函数的<strong>嵌套定义(Nested  Definnitions)</strong>, 其实就是在一个函数内定义函数, 在讲嵌套定义之前, 我们先回忆一下之前说过的, 把 <code>def</code> 语句理解为一个赋值语句. 理解了这个, 我们再理解函数的嵌套定义就很简单了.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">x</span>):<br>    ...<br>  ...<br></code></pre></td></tr></table></figure><p>在上面的代码块中, 我们在函数 <code>f</code> 里定义了一个函数 <code>g</code>, 如果我们按照 C&#x2F;C++ 里的方式来理解的话, 这可能会有些奇怪, 但是当你用 python 中<strong>名</strong>的视角来看, 定义一个函数跟定义一个变量没什么两样, 在这里定义一个函数无异于定义了一个<strong>函数类型</strong>的<strong>名</strong>.</p><p>所以, 函数的嵌套定义, 我们可以把它理解为在函数的作用域内定义了一个<strong>名</strong>, 只不过这个名被赋予了<strong>函数</strong>的意义.</p><h3 id="Functions-as-Returned-Values"><a href="#Functions-as-Returned-Values" class="headerlink" title="Functions as Returned Values"></a>Functions as Returned Values</h3><p>前面说完了函数作为参数传入, 接下来是函数作为返回值传出.</p><p>这里的函数作为返回值真的是返回了一个函数, 与函数的递归调用不同, 这里的返回一个函数, 是真的把函数作为返回值.</p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> f(g(x))<br>  <span class="hljs-keyword">return</span> h<br></code></pre></td></tr></table></figure><p>函数 <code>compose1</code> 把两个只有一个参数的函数 <code>f(x)</code> 和 <code>g(x)</code> 合并成一个函数 <code>h(x)</code>.</p><p>我们可以通过如下方式调用:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">h = compose1(f, g)<br></code></pre></td></tr></table></figure><p>是不是很简单, 其实就是返回值的类型为函数类型罢了.</p><p>不知道看到这里的你有没有个疑惑:</p><blockquote><p>为什么不直接在 Functions as Arguments 后面讲 Functions as Returned Values</p></blockquote><p>其实我刚才也有这个疑惑, 甚至我一开始还是把这两部分连着的, 把嵌套定义放在后面(当然CS61A中并没有这样), 在写嵌套定义那一部分的时候我突然发现, 函数作为返回值的时候, 如果不用嵌套定义, 那么我们的函数就会长成下面这样子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> f<br></code></pre></td></tr></table></figure><p>我们就只能返回一个函数本身或者一个其他函数, 但是这样的功能我们本可以直接用一个 <code>=</code> 来实现, 写的这么麻烦实在很不符合一个优秀程序员的作风.</p><p>为了让函数类型的返回值更有意义, 我就把这一节放在了函数的嵌套定义之后, 想必 CS61A 课程安排成这样大概也是如此吧.</p><h3 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h3><p><strong>加里化(Currying)</strong>, 这真是个有趣的东西, 因为我一开始并不知道这是什么玩意, 于是我就翻译了一下, 翻译结果是”咖喱ing”, 我的大脑突然一片空白. 不过这个名字并不重要, 重要的是加里化这个操作.</p><blockquote><p>We can use higher-order functions to convert a function that takes multiple arguments into a chain of functions that each take a single argument.</p></blockquote><p>上面是对加里化的一个简单的解释, 把一个形似 <code>f(a, b, c...)</code> 的函数转化成形似 <code>g(a)(b)(c)...</code> 的形式, 这个操作就是加里化.</p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">x, y</span>):<br>  total, k = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> k &lt; y<br>    total, k = total * x, k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>这是一个用于计算 $x^y$ 的函数, 我们对其加里化:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">curried_pow</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x, y)<br>  <span class="hljs-keyword">return</span> h<br></code></pre></td></tr></table></figure><p><code>curried_pow(x)(y)</code> 的结果与 <code>pow(x, y)</code> 完全相同, 除此之外,  <code>curried_pow(x)</code> 也可以作为单独的一个函数使用, 把 <code>x</code> 作为一个常量, 例如 <code>curried_pow(2)(x)</code> 就可以用于计算 $2^x$ .</p><p>只是说到这里, 还不足以体现出加里化的作用和优点, 加里化的一个很重要的作用就是可以把一个多参数的函数当作一个单参数的函数来使用, 举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">map_to_range</span>(<span class="hljs-params">start, end, f</span>):<br>  <span class="hljs-keyword">while</span> start &lt; end:<br>    <span class="hljs-built_in">print</span>(f(start))<br>    start = start + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个函数用于输出 $f(n), n \in [start, end)$, 显然函数 <code>f</code> 只有一个参数, 所以我们就可以通过对函数 <code>pow</code> 加里化来获取单参数函数, 并且可以以参数的形式任意修改其他参数, 也就是说, 我们只需要对 <code>pow(x, y)</code> 进行加里化, 就可以得到所有的用于计算 $a^x$ 的函数, 此处 $a$ 为常数. 我们就不需要用一个函数就定义一个, 只需要在调用或是传入 <code>curried_pow(x)</code> 时修改 <code>x</code> 的值就可以了.</p><h3 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><p>目前来看, 我们每次需要用一个函数时, 都需要一个名, 也就是我们都是通过一个名来调用函数.</p><p><strong>lambda 表达式</strong>的出现改变了这一情况. 通过 lambda 表达式, 我们可以把上面的 <code>compose1</code> 函数写成如下形式:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> x : f(g(x))<br></code></pre></td></tr></table></figure><p>这与上面的定义是等价的. lambda 表达式的格式如下:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">    <span class="hljs-variable">lambda</span>            <span class="hljs-variable">x</span>            :         <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-title">g</span>(<span class="hljs-variable">x</span>))</span><br><span class="hljs-variable">A</span> <span class="hljs-variable">function</span> <span class="hljs-variable">that</span>    <span class="hljs-variable">takes</span> <span class="hljs-variable">x</span>    <span class="hljs-variable"><span class="hljs-keyword">and</span></span> <span class="hljs-variable">returns</span>    <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-title">g</span>(<span class="hljs-variable">x</span>))</span><br></code></pre></td></tr></table></figure><p>lambda 表达式的值是一个函数, 称为 lambda 函数. 有了 lambda 表达式, 我们就可以换一种方式来对函数进行定义了:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">f = <span class="hljs-keyword">lambda</span> x : x * x<br></code></pre></td></tr></table></figure><p>这样就定义了一个函数 <code>f(x)</code> 用于计算 $x^2$. 通过 lambda 表达式的方式定义函数会很简短, 在某些情况下非常好用. 但需要注意的是, lambda 表达式只能用于简单的函数定义(仅包含一个表达式), 而不能含有赋值语句或控制语句. 如果过分使用 lambda 表达式也会造成代码可读性下降等问题.</p><p>所以凡事都讲究一个中庸之道, 过犹不及. 对 lambda 表达式抑或是其他特性都是如此.</p><h3 id="Function-Decorators"><a href="#Function-Decorators" class="headerlink" title="Function Decorators"></a>Function Decorators</h3><p><strong>函数装饰器(Function Decorators)</strong>, 正如其名, 是一个用于”装饰”函数的东西, 符号 <code>@</code> 称为<strong>装饰器(Decorator)</strong>, 我们可以通过它来调用装饰函数来对目标函数进行装饰.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">fn</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt;&#x27;</span>, fn, <span class="hljs-string">&#x27;(&#x27;</span>, x, <span class="hljs-string">&#x27;)&#x27;</span>)<br>    <span class="hljs-keyword">return</span> fn(x)<br>  <span class="hljs-keyword">return</span> wrapped<br></code></pre></td></tr></table></figure><p>这是一个用于追踪函数的函数, 可以输出目标函数的信息及其传入的参数, 并且没有修改其返回值. 我们通过以下方式来定义一个修饰过后的函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">@trace</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br></code></pre></td></tr></table></figure><p>当然我们也可以先定义该函数, 再对其进行修饰:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br><br>triple = trace(triple)<br></code></pre></td></tr></table></figure><p>这两种方式是等价的, 只不过后者就不需要用到装饰器了.</p><p>这里只是简要的介绍了函数装饰器, 就像 CS61A 中讲的那样, 并没有对其进行深入的探讨和研究, 也没有介绍其应用范围.</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Learning Chapter 1</title>
    <link href="/2024/07/03/Python-Learning-Chapter-1/"/>
    <url>/2024/07/03/Python-Learning-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Learning-Chapter-1"><a href="#Python-Learning-Chapter-1" class="headerlink" title="Python Learning Chapter 1"></a>Python Learning Chapter 1</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>之前用过 python, 但是没学过, 或者说没系统的学过, 所以打算系统的学习一下, 以便了解一些 python 的特性和用法.</p><p>因为我是跟着英文资料(CS61A Textbook)学的, 所以标题和定义基本采用英文, 但是由于我个人的英语水平有限, 内容还是中文写的.</p><h2 id="Some-Features"><a href="#Some-Features" class="headerlink" title="Some Features"></a>Some Features</h2><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>与 C&#x2F;C++ 不同, python 的变量不需要进行声明即可赋值, 也就是说, 在 python 中, 变量是没有一个确定的类型的, 甚至一个变量可以赋值为一个函数来使用(当然赋值为一个函数之后, 其使用方法也与该函数完全一致了), 反之亦然, 一个函数名也可以赋值后作为一个变量来使用, 只不过在赋值为一个变量后, 该函数名就不能作为一个函数来使用了, 而是变成了一个变量. 为了方便描述和理解, 我们不妨统一称“函数名”和“变量名”为“名”(name), </p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span> = <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span><br><span class="hljs-number">3</span><br>&gt;&gt;&gt;<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span><br></code></pre></td></tr></table></figure><p>在这个例子中, <code>max</code> 是 <code>python</code> 内置的一个函数, 我们将其赋值为一个数之后, <code>max</code> 就变成了一个变量, 而不是一个函数, 此时若再将其作为一个函数来使用则会报错.</p><h3 id="Assignment-Statement"><a href="#Assignment-Statement" class="headerlink" title="Assignment Statement"></a>Assignment Statement</h3><p>python 支持同时为多个名进行赋值, 只需要在 <code>=</code> 两端用 <code>,</code> 隔开即可.</p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>y<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>=</code> 右端与常规的对单个名的赋值完全一样, 既可以是数, 也可以是表达式. 与对左侧的变量依次赋值有不同的是, python 会先把右侧的值计算完, 然后再为左侧的名进行赋值, 也就是说, 先执行对右侧的计算, 再执行对左侧的赋值.</p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = y, x<br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>y<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>通过这个例子我们还可以找到一个交换两个名的方法.</p><p>既然是对名进行操作了, 当然既可以是变量也可以是函数了.</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/02/hello-world/"/>
    <url>/2024/07/02/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>这是我的新博客, <a href="https://www.cnblogs.com/sshadows">之前的博客</a>是在学 OI 的时候搭建的, 是由一个二货中学生搞的, 里面都是他学 OI 的时候写的乱七八糟的东西, 有些东西现在看来有些可笑. 其实大部分东西在现在看来都挺可笑的.</p><p>我并不打算把之前的东西迁移过来了, 这个博客就只记录我大学及以后的相关学习和经历.</p><p>之前写过的很多东西我可能也会重新再写一次, 比如数据结构什么的, 经过了这几年, 我对竞赛时期学习的数据结构和算法还有其内部蕴含的思想的理解也进一步的加深了, 也许再写一次会有新的理解和收获.</p><p>总之, 欢迎来玩.</p>]]></content>
    
    
    <categories>
      
      <category>Story</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Something</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
