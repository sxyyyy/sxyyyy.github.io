<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python Learning Chapter 2</title>
    <link href="/2024/07/10/Python-Learning-Chapter-2/"/>
    <url>/2024/07/10/Python-Learning-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Learning-Chapter-2"><a href="#Python-Learning-Chapter-2" class="headerlink" title="Python Learning Chapter 2"></a>Python Learning Chapter 2</h1><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><p>一个<strong>函数</strong>的<strong>定义</strong>通常如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> &lt;name&gt;(&lt;formal parameters&gt;):<br>  ...<br>  <span class="hljs-keyword">return</span> ...<br></code></pre></td></tr></table></figure><p>开头为一个 <code>def</code> 语句, 然后是函数的名, 后面跟着 <code>()</code>, <code>()</code> 里是若干个用 <code>,</code> 隔开的形参. 下面是函数要进行的操作, 最后是一个 <code>return</code> 语句(可有可无)用于返回值.</p><p>函数的定义很简单, 接下来我们看一点抽象的东西.</p><p>我们知道, 给一个变量赋值用的是 <code>=</code>, 定义一个函数用的是 <code>def</code>, 无论是 <code>=</code> 还是 <code>def</code>, 其本质都是为一个<strong>名</strong>赋予<strong>含义</strong>, 换句话说, <code>def</code> 语句本质上也是一个<strong>赋值语句</strong>.</p><p>所以很多时候, 我们把函数的定义当作是对名的赋值就会好理解很多.</p><h3 id="Functions-as-Arguments"><a href="#Functions-as-Arguments" class="headerlink" title="Functions as Arguments"></a>Functions as Arguments</h3><p>观察以下几个函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + k, k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_cubes</span>(<span class="hljs-params">n</span>):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + k * k * k, k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pi_sum</span>(<span class="hljs-params">n</span>):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + <span class="hljs-number">8</span> / ((<span class="hljs-number">4</span> * k - <span class="hljs-number">3</span>) * (<span class="hljs-number">4</span> * k - <span class="hljs-number">1</span>)), k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>我们可以发现以上几个函数都可以写成如下格式:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> &lt;name&gt;(n):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + &lt;term&gt;(k), k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>只有函数名 <code>&lt;name&gt;</code> 和参数的计算方式 <code>&lt;term&gt;</code> 不同.</p><p>我们在上一章提到过, python 中不分函数名或是变量名, 而是统一称为<strong>名(name)</strong>, 既然这样, 我们在函数中传参的过程中, 也可以通过名的形式来传入一个函数, 即上面的 <code>&lt;term&gt;</code>.</p><p>也就是说, 我们可以把函数作为一个参数传入函数.</p><p>故函数 <code>sum_cubes</code> 的定义可以改写为如下形式:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">summation</span>(<span class="hljs-params">n, term</span>):<br>  total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> k &lt; n:<br>    total, k = total + term(k), k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> x * x * x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_cubes</span>(<span class="hljs-params">n</span>):<br>  <span class="hljs-keyword">return</span> summation(n, cube)<br></code></pre></td></tr></table></figure><p>只考虑计算立方和这一项功能的话, 把一个函数拆成这样三个函数来写可能有些不合适, 但是当我们把所有的可以用该格式概括的(前 n 项求和)函数都写成这样的形式, 那我们的代码复用性就大大的提高了, 这种模块化的思想是编程的哲学, 也是编程的艺术, 既提高了代码的复用性, 也提高了代码的美观程度.</p><h3 id="Nested-Definitions"><a href="#Nested-Definitions" class="headerlink" title="Nested Definitions"></a>Nested Definitions</h3><p>函数的<strong>嵌套定义(Nested  Definnitions)</strong>, 其实就是在一个函数内定义函数, 在讲嵌套定义之前, 我们先回忆一下之前说过的, 把 <code>def</code> 语句理解为一个赋值语句. 理解了这个, 我们再理解函数的嵌套定义就很简单了.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">x</span>):<br>    ...<br>  ...<br></code></pre></td></tr></table></figure><p>在上面的代码块中, 我们在函数 <code>f</code> 里定义了一个函数 <code>g</code>, 如果我们按照 C&#x2F;C++ 里的方式来理解的话, 这可能会有些奇怪, 但是当你用 python 中<strong>名</strong>的视角来看, 定义一个函数跟定义一个变量没什么两样, 在这里定义一个函数无异于定义了一个<strong>函数类型</strong>的<strong>名</strong>.</p><p>所以, 函数的嵌套定义, 我们可以把它理解为在函数的作用域内定义了一个<strong>名</strong>, 只不过这个名被赋予了<strong>函数</strong>的意义.</p><h3 id="Functions-as-Returned-Values"><a href="#Functions-as-Returned-Values" class="headerlink" title="Functions as Returned Values"></a>Functions as Returned Values</h3><p>前面说完了函数作为参数传入, 接下来是函数作为返回值传出.</p><p>这里的函数作为返回值真的是返回了一个函数, 与函数的递归调用不同, 这里的返回一个函数, 是真的把函数作为返回值.</p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> f(g(x))<br>  <span class="hljs-keyword">return</span> h<br></code></pre></td></tr></table></figure><p>函数 <code>compose1</code> 把两个只有一个参数的函数 <code>f(x)</code> 和 <code>g(x)</code> 合并成一个函数 <code>h(x)</code>.</p><p>我们可以通过如下方式调用:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">h = compose1(f, g)<br></code></pre></td></tr></table></figure><p>是不是很简单, 其实就是返回值的类型为函数类型罢了.</p><p>不知道看到这里的你有没有个疑惑:</p><blockquote><p>为什么不直接在 Functions as Arguments 后面讲 Functions as Returned Values</p></blockquote><p>其实我刚才也有这个疑惑, 甚至我一开始还是把这两部分连着的, 把嵌套定义放在后面(当然CS61A中并没有这样), 在写嵌套定义那一部分的时候我突然发现, 函数作为返回值的时候, 如果不用嵌套定义, 那么我们的函数就会长成下面这样子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> f<br></code></pre></td></tr></table></figure><p>我们就只能返回一个函数本身或者一个其他函数, 但是这样的功能我们本可以直接用一个 <code>=</code> 来实现, 写的这么麻烦实在很不符合一个优秀程序员的作风.</p><p>为了让函数类型的返回值更有意义, 我就把这一节放在了函数的嵌套定义之后, 想必 CS61A 课程安排成这样大概也是如此吧.</p><h3 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h3><p><strong>加里化(Currying)</strong>, 这真是个有趣的东西, 因为我一开始并不知道这是什么玩意, 于是我就翻译了一下, 翻译结果是”咖喱ing”, 我的大脑突然一片空白. 不过这个名字并不重要, 重要的是加里化这个操作.</p><blockquote><p>We can use higher-order functions to convert a function that takes multiple arguments into a chain of functions that each take a single argument.</p></blockquote><p>上面是对加里化的一个简单的解释, 把一个形似 <code>f(a, b, c...)</code> 的函数转化成形似 <code>g(a)(b)(c)...</code> 的形式, 这个操作就是加里化.</p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">x, y</span>):<br>  total, k = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> k &lt; y<br>    total, k = total * x, k + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>这是一个用于计算 $x^y$ 的函数, 我们对其加里化:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">curried_pow</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x, y)<br>  <span class="hljs-keyword">return</span> h<br></code></pre></td></tr></table></figure><p><code>curried_pow(x)(y)</code> 的结果与 <code>pow(x, y)</code> 完全相同, 除此之外,  <code>curried_pow(x)</code> 也可以作为单独的一个函数使用, 把 <code>x</code> 作为一个常量, 例如 <code>curried_pow(2)(x)</code> 就可以用于计算 $2^x$ .</p><p>只是说到这里, 还不足以体现出加里化的作用和优点, 加里化的一个很重要的作用就是可以把一个多参数的函数当作一个单参数的函数来使用, 举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">map_to_range</span>(<span class="hljs-params">start, end, f</span>):<br>  <span class="hljs-keyword">while</span> start &lt; end:<br>    <span class="hljs-built_in">print</span>(f(start))<br>    start = start + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个函数用于输出 $f(n), n \in [start, end)$, 显然函数 <code>f</code> 只有一个参数, 所以我们就可以通过对函数 <code>pow</code> 加里化来获取单参数函数, 并且可以以参数的形式任意修改其他参数, 也就是说, 我们只需要对 <code>pow(x, y)</code> 进行加里化, 就可以得到所有的用于计算 $a^x$ 的函数, 此处 $a$ 为常数. 我们就不需要用一个函数就定义一个, 只需要在调用或是传入 <code>curried_pow(x)</code> 时修改 <code>x</code> 的值就可以了.</p><h3 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><p>目前来看, 我们每次需要用一个函数时, 都需要一个名, 也就是我们都是通过一个名来调用函数.</p><p><strong>lambda 表达式</strong>的出现改变了这一情况. 通过 lambda 表达式, 我们可以把上面的 <code>compose1</code> 函数写成如下形式:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> x : f(g(x))<br></code></pre></td></tr></table></figure><p>这与上面的定义是等价的. lambda 表达式的格式如下:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">    <span class="hljs-variable">lambda</span>            <span class="hljs-variable">x</span>            :         <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-title">g</span>(<span class="hljs-variable">x</span>))</span><br><span class="hljs-variable">A</span> <span class="hljs-variable">function</span> <span class="hljs-variable">that</span>    <span class="hljs-variable">takes</span> <span class="hljs-variable">x</span>    <span class="hljs-variable"><span class="hljs-keyword">and</span></span> <span class="hljs-variable">returns</span>    <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-title">g</span>(<span class="hljs-variable">x</span>))</span><br></code></pre></td></tr></table></figure><p>lambda 表达式的值是一个函数, 称为 lambda 函数. 有了 lambda 表达式, 我们就可以换一种方式来对函数进行定义了:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">f = <span class="hljs-keyword">lambda</span> x : x * x<br></code></pre></td></tr></table></figure><p>这样就定义了一个函数 <code>f(x)</code> 用于计算 $x^2$. 通过 lambda 表达式的方式定义函数会很简短, 在某些情况下非常好用. 但需要注意的是, lambda 表达式只能用于简单的函数定义(仅包含一个表达式), 而不能含有赋值语句或控制语句. 如果过分使用 lambda 表达式也会造成代码可读性下降等问题.</p><p>所以凡事都讲究一个中庸之道, 过犹不及. 对 lambda 表达式抑或是其他特性都是如此.</p><h3 id="Function-Decorators"><a href="#Function-Decorators" class="headerlink" title="Function Decorators"></a>Function Decorators</h3><p><strong>函数装饰器(Function Decorators)</strong>, 正如其名, 是一个用于”装饰”函数的东西, 符号 <code>@</code> 称为<strong>装饰器(Decorator)</strong>, 我们可以通过它来调用装饰函数来对目标函数进行装饰.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">fn</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt;&#x27;</span>, fn, <span class="hljs-string">&#x27;(&#x27;</span>, x, <span class="hljs-string">&#x27;)&#x27;</span>)<br>    <span class="hljs-keyword">return</span> fn(x)<br>  <span class="hljs-keyword">return</span> wrapped<br></code></pre></td></tr></table></figure><p>这是一个用于追踪函数的函数, 可以输出目标函数的信息及其传入的参数, 并且没有修改其返回值. 我们通过以下方式来定义一个修饰过后的函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">@trace</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br></code></pre></td></tr></table></figure><p>当然我们也可以先定义该函数, 再对其进行修饰:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br><br>triple = trace(triple)<br></code></pre></td></tr></table></figure><p>这两种方式是等价的, 只不过后者就不需要用到装饰器了.</p><p>这里只是简要的介绍了函数装饰器, 就像 CS61A 中讲的那样, 并没有对其进行深入的探讨和研究, 也没有介绍其应用范围.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Learning Chapter 1</title>
    <link href="/2024/07/03/Python-Learning-Chapter-1/"/>
    <url>/2024/07/03/Python-Learning-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Learning-Chapter-1"><a href="#Python-Learning-Chapter-1" class="headerlink" title="Python Learning Chapter 1"></a>Python Learning Chapter 1</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>之前用过 python, 但是没学过, 或者说没系统的学过, 所以打算系统的学习一下, 以便了解一些 python 的特性和用法.</p><p>因为我是跟着英文资料(CS61A Textbook)学的, 所以标题和定义基本采用英文, 但是由于我个人的英语水平有限, 内容还是中文写的.</p><h2 id="Some-Features"><a href="#Some-Features" class="headerlink" title="Some Features"></a>Some Features</h2><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>与 C&#x2F;C++ 不同, python 的变量不需要进行声明即可赋值, 也就是说, 在 python 中, 变量是没有一个确定的类型的, 甚至一个变量可以赋值为一个函数来使用(当然赋值为一个函数之后, 其使用方法也与该函数完全一致了), 反之亦然, 一个函数名也可以赋值后作为一个变量来使用, 只不过在赋值为一个变量后, 该函数名就不能作为一个函数来使用了, 而是变成了一个变量. 为了方便描述和理解, 我们不妨统一称“函数名”和“变量名”为“名”(name), </p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span> = <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span><br><span class="hljs-number">3</span><br>&gt;&gt;&gt;<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span><br></code></pre></td></tr></table></figure><p>在这个例子中, <code>max</code> 是 <code>python</code> 内置的一个函数, 我们将其赋值为一个数之后, <code>max</code> 就变成了一个变量, 而不是一个函数, 此时若再将其作为一个函数来使用则会报错.</p><h3 id="Assignment-Statement"><a href="#Assignment-Statement" class="headerlink" title="Assignment Statement"></a>Assignment Statement</h3><p>python 支持同时为多个名进行赋值, 只需要在 <code>=</code> 两端用 <code>,</code> 隔开即可.</p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>y<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>=</code> 右端与常规的对单个名的赋值完全一样, 既可以是数, 也可以是表达式. 与对左侧的变量依次赋值有不同的是, python 会先把右侧的值计算完, 然后再为左侧的名进行赋值, 也就是说, 先执行对右侧的计算, 再执行对左侧的赋值.</p><p>举个例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = y, x<br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>y<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>通过这个例子我们还可以找到一个交换两个名的方法.</p><p>既然是对名进行操作了, 当然既可以是变量也可以是函数了.</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/02/hello-world/"/>
    <url>/2024/07/02/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>这是我的新博客, <a href="https://www.cnblogs.com/sshadows">之前的博客</a>是在学 OI 的时候搭建的, 是由一个二货中学生搞的, 里面都是他学 OI 的时候写的乱七八糟的东西, 有些东西现在看来有些可笑. 其实大部分东西在现在看来都挺可笑的.</p><p>我并不打算把之前的东西迁移过来了, 这个博客就只记录我大学及以后的相关学习和经历.</p><p>之前写过的很多东西我可能也会重新再写一次, 比如数据结构什么的, 经过了这几年, 我对竞赛时期学习的数据结构和算法还有其内部蕴含的思想的理解也进一步的加深了, 也许再写一次会有新的理解和收获.</p><p>总之, 欢迎来玩.</p>]]></content>
    
    
    <categories>
      
      <category>Story</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Something</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
